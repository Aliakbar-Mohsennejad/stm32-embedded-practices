/**
 * Smart Irrigation System – STM32 HAL (Question 2)
 * Relay on PA0, RTC-based schedule at 09:00 and 21:00 for 10 minutes
 * EXTI0 button toggles system Enabled/Disabled
 */

#include "stm32f1xx_hal.h"  // change family header if needed

/* ==== User-configurable pins ==== */
#define RELAY_GPIO_Port     GPIOA
#define RELAY_Pin           GPIO_PIN_0     // Relay output

#define BTN_GPIO_Port       GPIOA
#define BTN_Pin             GPIO_PIN_1     // EXTI1 used in this example; set to EXTI0 if HW is PA0 used by relay

/* ==== Globals ==== */
RTC_HandleTypeDef hrtc;

typedef enum { ACT_NONE=0, ACT_START_IRR, ACT_STOP_IRR } action_t;

volatile uint8_t  g_system_enabled = 1;       // 1=Enabled, 0=Disabled
volatile uint8_t  g_irrigating     = 0;       // Relay state (logical)
volatile action_t g_next_action    = ACT_NONE;
volatile uint32_t g_last_btn_ms    = 0;       // Debounce

/* ==== Forward declarations ==== */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_RTC_Init(void);

static void Relay_On(void);
static void Relay_Off(void);

static void Schedule_Next_Start(void);
static void Schedule_Stop_After_10min(void);
static void Set_Alarm_Absolute(uint8_t hh, uint8_t mm, uint8_t ss);
static void Set_Alarm_Offset_Seconds(uint32_t add_sec);

static void ComputeNextStartHM(const RTC_TimeTypeDef* t, const RTC_DateTypeDef* d,
                               uint8_t* next_hh, uint8_t* next_mm);

/* ========================================================= */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_RTC_Init();

  /* On boot, ensure relay is off */
  Relay_Off();

  /* If system is enabled, schedule the next irrigation start */
  if (g_system_enabled) {
    Schedule_Next_Start();
  }

  while (1) {
    /* Nothing heavy here. RTC Alarm + EXTI drive the logic. */
    HAL_Delay(50);
  }
}

/* =========================================================
 *                    RTC & Scheduling
 * ========================================================= */

/**
 * @brief Decide whether the next start is today/tomorrow at 09:00 or 21:00,
 *        then set RTC Alarm A accordingly.
 */
static void Schedule_Next_Start(void)
{
  RTC_TimeTypeDef now_t; RTC_DateTypeDef now_d;
  HAL_RTC_GetTime(&hrtc, &now_t, RTC_FORMAT_BIN);
  HAL_RTC_GetDate(&hrtc, &now_d, RTC_FORMAT_BIN);

  uint8_t hh, mm;
  ComputeNextStartHM(&now_t, &now_d, &hh, &mm);

  g_next_action = ACT_START_IRR;
  Set_Alarm_Absolute(hh, mm, 0);
}

/**
 * @brief After turning the relay on, schedule a stop exactly after 10 minutes (600 s).
 */
static void Schedule_Stop_After_10min(void)
{
  g_next_action = ACT_STOP_IRR;
  Set_Alarm_Offset_Seconds(600);
}

/**
 * @brief Given current time, choose the next slot among 09:00 and 21:00.
 *        If current time is before 09:00 -> 09:00 today
 *        else if before 21:00 -> 21:00 today
 *        else -> 09:00 tomorrow
 */
static void ComputeNextStartHM(const RTC_TimeTypeDef* t, const RTC_DateTypeDef* d,
                               uint8_t* next_hh, uint8_t* next_mm)
{
  uint32_t mm_now = t->Hours * 60 + t->Minutes;
  uint32_t mm_9   = 9 * 60;
  uint32_t mm_21  = 21 * 60;

  if (mm_now < mm_9) {
    *next_hh = 9;  *next_mm = 0;           // Today 09:00
  } else if (mm_now < mm_21) {
    *next_hh = 21; *next_mm = 0;           // Today 21:00
  } else {
    *next_hh = 9;  *next_mm = 0;           // Tomorrow 09:00 (alarm set by absolute time; midnight wrap handled by HW)
  }
}

/**
 * @brief Program Alarm A to a specific time (HH:MM:SS) on the same day.
 *        If that time already passed today, most HAL RTCs will trigger next day automatically
 *        (implementation depends on family; for strictness you can roll the date yourself).
 */
static void Set_Alarm_Absolute(uint8_t hh, uint8_t mm, uint8_t ss)
{
  RTC_AlarmTypeDef sAlarm = {0};

  sAlarm.Alarm = RTC_ALARM_A;
  sAlarm.AlarmTime.Hours   = hh;
  sAlarm.AlarmTime.Minutes = mm;
  sAlarm.AlarmTime.Seconds = ss;
  sAlarm.AlarmMask         = RTC_ALARMMASK_DATEWEEKDAY; // daily alarm (ignore date)
  sAlarm.AlarmSubSecondMask= RTC_ALARMSUBSECONDMASK_ALL;

  HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
  HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN);
}

/**
 * @brief Program Alarm A to "now + add_sec".
 */
static void Set_Alarm_Offset_Seconds(uint32_t add_sec)
{
  RTC_TimeTypeDef t; RTC_DateTypeDef d;
  HAL_RTC_GetTime(&hrtc, &t, RTC_FORMAT_BIN);
  HAL_RTC_GetDate(&hrtc, &d, RTC_FORMAT_BIN);

  uint32_t now = t.Hours*3600 + t.Minutes*60 + t.Seconds;
  uint32_t trg = (now + add_sec) % 86400;

  uint8_t hh = (trg / 3600) % 24;
  uint8_t mm = (trg / 60) % 60;
  uint8_t ss = trg % 60;

  Set_Alarm_Absolute(hh, mm, ss);
}

/* =========================================================
 *                   Relay control helpers
 * ========================================================= */
static void Relay_On(void)
{
  HAL_GPIO_WritePin(RELAY_GPIO_Port, RELAY_Pin, GPIO_PIN_SET);
  g_irrigating = 1;
}

static void Relay_Off(void)
{
  HAL_GPIO_WritePin(RELAY_GPIO_Port, RELAY_Pin, GPIO_PIN_RESET);
  g_irrigating = 0;
}

/* =========================================================
 *                   RTC Callbacks (HAL)
 * ========================================================= */
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hr)
{
  if (!g_system_enabled) {
    /* If disabled meanwhile, ensure relay is OFF and do not chain actions */
    Relay_Off();
    g_next_action = ACT_NONE;
    return;
  }

  if (g_next_action == ACT_START_IRR) {
    /* Start watering */
    Relay_On();
    /* Chain stop after 10 minutes */
    Schedule_Stop_After_10min();
  }
  else if (g_next_action == ACT_STOP_IRR) {
    /* Stop watering and schedule the next daily start */
    Relay_Off();
    Schedule_Next_Start();
  }
}

/* =========================================================
 *                   EXTI (button) – Enable/Disable
 * ========================================================= */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if (GPIO_Pin == BTN_Pin) {
    uint32_t now = HAL_GetTick();
    if (now - g_last_btn_ms < 120) return;  // debounce ~120 ms
    g_last_btn_ms = now;

    g_system_enabled ^= 1;  // toggle

    if (!g_system_enabled) {
      /* On disable: stop relay and cancel pending chain */
      Relay_Off();
      g_next_action = ACT_NONE;
      HAL_RTC_DeactivateAlarm(&hrtc, RTC_ALARM_A);
    } else {
      /* On enable: schedule next start */
      if (!g_irrigating) {
        Schedule_Next_Start();
      }
    }
  }
}

/* =========================================================
 *                  Minimal init stubs (CubeMX)
 * ========================================================= */

static void MX_GPIO_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* Relay output PA0 */
  GPIO_InitStruct.Pin   = RELAY_Pin;
  GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(RELAY_GPIO_Port, &GPIO_InitStruct);
  HAL_GPIO_WritePin(RELAY_GPIO_Port, RELAY_Pin, GPIO_PIN_RESET);

  /* Button input with EXTI (example on PA1 -> EXTI1). 
     If your hardware uses EXTI0 on another pin, change mapping accordingly. */
  GPIO_InitStruct.Pin  = BTN_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;   // use FALLING or RISING per wiring
  GPIO_InitStruct.Pull = GPIO_PULLUP;            // or PULLDOWN per wiring
  HAL_GPIO_Init(BTN_GPIO_Port, &GPIO_InitStruct);

  /* NVIC for EXTI line */
  HAL_NVIC_SetPriority(EXTI1_IRQn, 2, 0);
  HAL_NVIC_EnableIRQ(EXTI1_IRQn);
}

static void MX_RTC_Init(void)
{
  /* Generate this with CubeMX:
     - Clock source: Prefer LSE (32.768 kHz) for accuracy
     - 24-hour format
     - Enable Alarm A interrupt
   */
  hrtc.Instance = RTC;
  hrtc.Init.AsynchPrediv = 0x7F;
  hrtc.Init.SynchPrediv  = 0x00FF;
  hrtc.Init.HourFormat   = RTC_HOURFORMAT_24;
  if (HAL_RTC_Init(&hrtc) != HAL_OK) { Error_Handler(); }

  /* Enable Alarm interrupt in NVIC (usually done by CubeMX) */
  HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 1, 0);
  HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
}

/* IRQ Handlers (match your chosen EXTI line) */
void EXTI1_IRQHandler(void) { HAL_GPIO_EXTI_IRQHandler(BTN_Pin); }
void RTC_Alarm_IRQHandler(void) { HAL_RTC_AlarmIRQHandler(&hrtc); }

/* Provide your SystemClock_Config() tailored by CubeMX */
void SystemClock_Config(void) { /* ... generated by CubeMX ... */ }

/* Simple error trap */
void Error_Handler(void) { __disable_irq(); while(1){} }
