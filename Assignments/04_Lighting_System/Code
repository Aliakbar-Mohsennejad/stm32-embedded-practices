/**
 * Three-Level Lighting Controller with AUTO mode (Assignment 4)
 * STM32 HAL (F1 example) – English commented
 *
 * Outputs:
 *  - PA0, PA1, PA2 -> brightness level encoding:
 *      OFF   : 000
 *      LOW   : 001 (PA0)
 *      MED   : 011 (PA0+PA1)
 *      HIGH  : 111 (PA0+PA1+PA2)
 *
 * Button (mode cycle): PC13 -> EXTI15_10 IRQ
 * AUTO indicator LED (green): PA3 (ON in AUTO, OFF otherwise)
 * ERROR indicator LED (red):  PA4 (blink 300/700 ms when RTC invalid)
 *
 * AUTO schedule:
 *   06:00–17:00 -> HIGH
 *   17:00–23:00 -> MEDIUM
 *   23:00–06:00 -> LOW
 *
 * RTC validity:
 *  - Use backup register flag (e.g., BKP_DR1 == 0x32F2) to mark “time configured”.
 *  - If invalid at boot, enter ERROR and blink red; ignore AUTO/time.
 *  - Once time becomes valid (external setting), transition to AUTO immediately and apply level.
 *
 * Notes:
 *  - Generate SystemClock_Config, MX_GPIO_Init, MX_RTC_Init with CubeMX.
 *  - Prefer LSE (32.768 kHz) for precise RTC. Enable RTC second event interrupt.
 */

#include "stm32f1xx_hal.h"

/* ===== Pins (edit as needed) ===== */
#define L0_Port   GPIOA
#define L0_Pin    GPIO_PIN_0  // PA0
#define L1_Port   GPIOA
#define L1_Pin    GPIO_PIN_1  // PA1
#define L2_Port   GPIOA
#define L2_Pin    GPIO_PIN_2  // PA2

#define LED_AUTO_Port  GPIOA
#define LED_AUTO_Pin   GPIO_PIN_3  // green: ON in AUTO
#define LED_ERR_Port   GPIOA
#define LED_ERR_Pin    GPIO_PIN_4  // red: blink when RTC invalid

#define BTN_Port  GPIOC
#define BTN_Pin   GPIO_PIN_13      // mode cycle button (EXTI line 13)

/* ===== Globals ===== */
RTC_HandleTypeDef hrtc;

typedef enum {
  MODE_OFF = 0,
  MODE_LOW,
  MODE_MED,
  MODE_HIGH,
  MODE_AUTO,
  MODE_ERROR_RTC
} mode_t;

volatile mode_t g_mode = MODE_ERROR_RTC;
volatile uint32_t g_last_btn_ms = 0;

/* ===== Prototypes ===== */
void SystemClock_Config(void);
static void MX_GPIO_Init(void);
static void MX_RTC_Init(void);

static uint8_t RTC_IsValid(void);
static void    ApplyLevel_Manual(mode_t m);
static void    ApplyLevel_Bits(uint8_t b0, uint8_t b1, uint8_t b2);
static void    SetMode(mode_t m);
static mode_t  NextMode(mode_t cur);

static mode_t  AutoLevelForTime(uint8_t h, uint8_t m);
static void    RefreshAutoFromRTC(void);
static void    UpdateIndicators(uint32_t ms);

/* ===== Main ===== */
int main(void)
{
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_RTC_Init();

  /* Decide initial mode based on RTC validity */
  if (RTC_IsValid()) SetMode(MODE_AUTO);
  else               SetMode(MODE_ERROR_RTC);

  uint32_t last_refresh = 0;

  while (1)
  {
    uint32_t now = HAL_GetTick();

    /* If RTC was invalid but becomes valid later (time set externally), jump to AUTO */
    if (g_mode == MODE_ERROR_RTC && RTC_IsValid()) {
      SetMode(MODE_AUTO);
    }

    /* In AUTO, periodically (or per second interrupt) recompute and apply level from RTC */
    if (g_mode == MODE_AUTO && now - last_refresh >= 300) {
      last_refresh = now;
      RefreshAutoFromRTC();
    }

    /* Blink/indicators update (non-blocking) */
    UpdateIndicators(now);

    HAL_Delay(20);
  }
}

/* ===== RTC validity via backup register flag (example: DR1 == 0x32F2) ===== */
static uint8_t RTC_IsValid(void)
{
  return (HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR1) == 0x32F2);
}

/* ===== Compute AUTO level from time =====
 * 06:00–17:00 -> HIGH
 * 17:00–23:00 -> MED
 * 23:00–06:00 -> LOW
 */
static mode_t AutoLevelForTime(uint8_t h, uint8_t m)
{
  uint16_t mm = h * 60 + m;
  if (mm >= 6*60 && mm < 17*60)  return MODE_HIGH;
  if (mm >= 17*60 && mm < 23*60) return MODE_MED;
  return MODE_LOW; // 23:00–06:00
}

/* ===== Read RTC and apply AUTO level immediately ===== */
static void RefreshAutoFromRTC(void)
{
  if (!RTC_IsValid()) { SetMode(MODE_ERROR_RTC); return; }

  RTC_TimeTypeDef t; RTC_DateTypeDef d;
  HAL_RTC_GetTime(&hrtc, &t, RTC_FORMAT_BIN);
  HAL_RTC_GetDate(&hrtc, &d, RTC_FORMAT_BIN);

  mode_t desired = AutoLevelForTime(t.Hours, t.Minutes);
  ApplyLevel_Manual(desired);  // reuse manual applier for bit patterns
}

/* ===== Set outputs per mode (manual levels only) ===== */
static void ApplyLevel_Manual(mode_t m)
{
  switch (m) {
    case MODE_OFF:  ApplyLevel_Bits(0,0,0); break;
    case MODE_LOW:  ApplyLevel_Bits(1,0,0); break;
    case MODE_MED:  ApplyLevel_Bits(1,1,0); break;
    case MODE_HIGH: ApplyLevel_Bits(1,1,1); break;
    default: break;
  }
}

/* ===== Drive PA0/PA1/PA2 by bits ===== */
static void ApplyLevel_Bits(uint8_t b0, uint8_t b1, uint8_t b2)
{
  HAL_GPIO_WritePin(L0_Port, L0_Pin, b0 ? GPIO_PIN_SET : GPIO_PIN_RESET);
  HAL_GPIO_WritePin(L1_Port, L1_Pin, b1 ? GPIO_PIN_SET : GPIO_PIN_RESET);
  HAL_GPIO_WritePin(L2_Port, L2_Pin, b2 ? GPIO_PIN_SET : GPIO_PIN_RESET);
}

/* ===== Mode control ===== */
static void SetMode(mode_t m)
{
  g_mode = m;

  /* Safety: on any mode switch, ensure outputs reflect mode correctly */
  if (m == MODE_ERROR_RTC) {
    ApplyLevel_Bits(0,0,0); // lights off in error
    HAL_GPIO_WritePin(LED_AUTO_Port, LED_AUTO_Pin, GPIO_PIN_RESET); // AUTO LED off
    return;
  }

  if (m == MODE_AUTO) {
    HAL_GPIO_WritePin(LED_AUTO_Port, LED_AUTO_Pin, GPIO_PIN_SET);   // AUTO LED on
    RefreshAutoFromRTC();                                           // immediate apply
  } else {
    HAL_GPIO_WritePin(LED_AUTO_Port, LED_AUTO_Pin, GPIO_PIN_RESET); // AUTO LED off
    ApplyLevel_Manual(m);
  }
}

static mode_t NextMode(mode_t cur)
{
  /* Manual cycle: Off → Low → Med → High → Auto → Off → ... */
  switch (cur) {
    case MODE_OFF:  return MODE_LOW;
    case MODE_LOW:  return MODE_MED;
    case MODE_MED:  return MODE_HIGH;
    case MODE_HIGH: return MODE_AUTO;
    case MODE_AUTO: return MODE_OFF;
    case MODE_ERROR_RTC: return MODE_ERROR_RTC; // locked until RTC valid
  }
  return MODE_OFF;
}

/* ===== Indicators (green AUTO LED handled in SetMode; here handle ERROR blinking) ===== */
static void UpdateIndicators(uint32_t ms)
{
  if (g_mode == MODE_ERROR_RTC) {
    /* Red blink 300ms ON / 700ms OFF */
    if ((ms % 1000) < 300) HAL_GPIO_WritePin(LED_ERR_Port, LED_ERR_Pin, GPIO_PIN_SET);
    else                   HAL_GPIO_WritePin(LED_ERR_Port, LED_ERR_Pin, GPIO_PIN_RESET);
  } else {
    HAL_GPIO_WritePin(LED_ERR_Port, LED_ERR_Pin, GPIO_PIN_RESET);
  }
}

/* ===== Button: EXTI callback (mode cycle) ===== */
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
{
  if (GPIO_Pin == BTN_Pin) {
    uint32_t now = HAL_GetTick();
    if (now - g_last_btn_ms < 120) return; // debounce
    g_last_btn_ms = now;

    if (g_mode == MODE_ERROR_RTC) {
      /* Ignore presses until RTC is valid */
      return;
    }

    mode_t next = NextMode(g_mode);
    SetMode(next);
  }
}

/* ===== Optional: RTC second tick → immediate AUTO update (if enabled in MX_RTC_Init) =====
   HAL provides this callback for RTC events (second/wakeup, family-dependent). */
void HAL_RTCEx_RTCEventCallback(RTC_HandleTypeDef *hrtc_)
{
  if (g_mode == MODE_AUTO) {
    RefreshAutoFromRTC();
  }
}

/* ===== IRQ handlers ===== */
void EXTI15_10_IRQHandler(void) { HAL_GPIO_EXTI_IRQHandler(BTN_Pin); }

/* ===== Minimal inits (generate with CubeMX and adjust) ===== */
static void MX_GPIO_Init(void)
{
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_AFIO_CLK_ENABLE();

  /* Optional: free JTAG to reclaim pins; keep SWD */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();

  GPIO_InitTypeDef gi = {0};

  /* Outputs: PA0..PA2 (levels), PA3 (AUTO LED), PA4 (ERR LED) */
  gi.Pin = L0_Pin | L1_Pin | L2_Pin | LED_AUTO_Pin | LED_ERR_Pin;
  gi.Mode = GPIO_MODE_OUTPUT_PP;
  gi.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &gi);

  HAL_GPIO_WritePin(L0_Port, L0_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(L1_Port, L1_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(L2_Port, L2_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(LED_AUTO_Port, LED_AUTO_Pin, GPIO_PIN_RESET);
  HAL_GPIO_WritePin(LED_ERR_Port, LED_ERR_Pin, GPIO_PIN_RESET);

  /* Button PC13 -> EXTI13 (pull-up example) */
  gi.Pin = BTN_Pin;
  gi.Mode = GPIO_MODE_IT_FALLING;   // Falling with pull-up wiring
  gi.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(BTN_Port, &gi);

  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 0);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
}

static void MX_RTC_Init(void)
{
  /* Configure RTC in CubeMX:
     - Clock source: LSE (preferred). If not available, LSI.
     - Enable RTC second event interrupt (or Wakeup) to get per-second callback if desired.
     - Set 24h format.
   */
  hrtc.Instance = RTC;
  hrtc.Init.AsynchPrediv = 0x7F;
  hrtc.Init.SynchPrediv  = 0x00FF;
  hrtc.Init.HourFormat   = RTC_HOURFORMAT_24;
  if (HAL_RTC_Init(&hrtc) != HAL_OK) { Error_Handler(); }

  /* NVIC for RTC events if required by your MX settings
     HAL_NVIC_SetPriority(RTC_IRQn, 1, 0);
     HAL_NVIC_EnableIRQ(RTC_IRQn); */

  /* RTC validity flag must be written elsewhere after time set:
     HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR1, 0x32F2);
   */
}

void SystemClock_Config(void)
{
  /* Generate with CubeMX per board (PLL/HSE/HSI).
     Keep clocks minimal when idle to save power. */
}

void Error_Handler(void)
{
  __disable_irq();
  while (1) {}
}
